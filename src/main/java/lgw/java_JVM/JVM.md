周阳老师视频笔记二（JVM）

1) 如何确定垃圾？

    1) 引用计数法
    
        无法解决循环引用问题，jdk不使用这种算法。
        
    2) 可达性分析算法
    
        枚举根节点做可达性分析，不可达即为垃圾。就是从 GC Root开始向下遍历搜索，能搜索到的（可达的）就是还在使用的java对象，搜索不到的（不可达的）就是垃圾。

2) 什么是GC Root？哪些对象可以作为 GC Root？

    1) 虚拟机栈中局部变量表引用的对象。
    
    2) 方法区中静态属性引用的对象。
    
    3) 方法区中常量引用的对象。
    
    4) 本地方法栈中native方法引用的对象。

3) 如何盘点查看 JVM 系统默认值？
    
    1) boolean型参数
    
        设置属性值：-XX:+或者-某个属性
        
        -（减号）表示没开启，+（加号）表示开启。
        
    2) KV设置类型
    
        设置属性值： -XX:key=value
        
    3) 查看属性的值
    
        1) 使用 jinfo -flag （参数名） （进程号） 查看某个参数是否开启。    
    
        2) 使用 jinfo -flags （进程号） 查看所有的参数值    
    
        3) java -XX:+PrintFlagsInitial    查看 JVM 初始化配置
    
        4) java -XX:+PrintFlagsFinal -version 主要用于查看修改更新  = 代表初始的值  := 代表修改以后的值
    
4) JVM常用的基本配置参数有哪些？

    1) -Xms
    
        初始内存大小，默认为物理内存的64分之1，等价于-XX:InitialHeapSize
    
    2) -Xmx
    
        最大分配内存，默认为物理内存的4分之1，等价于-XX:MaxHeapSize
    
    3) -Xss
    
        设置单个线程栈的默认初始大小，一般默认为512~1024k，等价于-XX:ThreadStackSize
    
    4) -Xmn
    
        设置新生代的大小，新生代默认是3分之1的堆内存。
    
    5) -XX:MetaSpaceSize
    
        设置元空间大小，元空间的本质和永久代类似，都是对方法区的实现。但是**元空间并不在虚拟机中**，而是**使用本地内存**。默认情况下，元空间的大小仅受本地内存限制。
    
    6) -XX:+PrintGCDetails
    
        打印GC的详细日志信息，如何阅读打印的内容，参考《深入理解java虚拟机》。
    
    7) -XX:SurvivorRatio
    
        设置新生代中E区和两个S区的比例，默认是8:1:1,例如： -XX:SurvivorRatio=4设置为 4:1:1 。
    
    8) -XX:NewRatio
    
        配置新生代和老年代在堆内存中的比例，默认是2，即新生代占1，老年代占2.新生代占老年代的3分之一。
    
    9) -XX:MaxTenuringThreshold
    
        设置对象在新生代经过多少次回收之后进入老年代，默认是15.取值应该在0~15之间。
    
5) 对强、软、弱、虚四种引用类型的理解

    java.lang.ref

    1) 强引用(Reference) demo2
    
        强引用对象就是普通的存活的java对象，对于这种强引用引用的对象，就算出现了OOM也不会对该对象进行回收。
    
    2) 软引用(SoftReference) demo3
    
        内存足够的时候不会被GC回收，当内存不够时才会被GC回收。
    
    3) 弱引用(WeakReference) demo4
    
        不考虑内存是否够用，只要进行GC就会回收。
        
        WeakHashMap
    
    4) 虚引用(PhantomReference) demo5
    
        1) 虚引用不会决定对象的周期，如果一个对象持有虚引用，它就像没有任何引用一样，在任何时候都可能被垃圾收集器回收。
        
        2) 它不能单独使用也不能通过他访问对象，必须和引用队列（ReferenceQueue）联合使用。

        3) 虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅提供一种确保对象被finalize以后，做某些事情的机制。
        
        4) PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。其意义说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的操作。
        
        5) 设置虚引用的唯一目的，就是在这个对象被收集器回收之后收到一个系统通知或者添加后续处理。    
        
        
        
        
        